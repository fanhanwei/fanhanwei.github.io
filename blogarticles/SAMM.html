<!DOCTYPE HTML>
<!--
	Massively by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>FAN, Hanwei 樊瀚伟 Blog</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="../assets/css/main.css" />
		<noscript><link rel="stylesheet" href="../assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<a href="../index.html" class="logo">FAN, Hanwei</a>
					</header>

				<!-- Nav -->
					<nav id="nav">
						<ul class="links">
							<li><a href="../index.html">About me</a></li>
							<li><a href="../RH.html">Recent Highlights</a></li>
							<li class="active"><a href="../Blog.html">Blog</a></li>
						</ul>
						<ul class="icons">
							<li><a href="MAILTO:hanweifan2018@outlook.com" class="icon regular fa-envelope"><span class="label">E-Mail</span></a></li>
							<li><a href="https://www.linkedin.com/in/hanwei-fan-bb3b69192/" class="icon brands fa-linkedin"><span class="label">Linkedin</span></a></li>
							<li><a href="https://www.instagram.com/fan.hanwei/" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>
							<li><a href="https://github.com/fanhanwei" class="icon brands fa-github"><span class="label">GitHub</span></a></li>
						</ul>
					</nav>

				<!-- Main -->
					<div id="main">
						<!-- Post -->
							<section class="post">
								<header class="major">
									<h1>Systolic Array Matrix Multiplication<br />通用脉动阵列及矩阵乘法</h1>
								</header>
									<dl>
										<dt>简介</dt>
										<dd>
											<p>脉动阵列，是现在某些智能加速芯片的一种架构；由一组处理单元 Processor Elements组成；
											处理单元简称是PE，也经常简称为Cell；所有的Cell是用Mesh结构互连起来；
											每个Cell处理一系列的流经自己的数据；之后传递给邻居的Cell，大部分的Cell都是相同的操作。<br />
											SIMD是和其相似的架构，但是SIMD如名字表达的那样，控制指令是唯一的，数据是不同的，并且数据从内存加载到PE；
											脉动阵列的区别是可能从片上的RAM加载到PE，并且每个PE有自己的控制单元，这样不仅仅是数据的并行了。</p>
										</dd>
										<dt>设计优势点</dt>
										<dd>
											<p>脉冲阵列用在专用的加速芯片上的优势是：<br />
											1. 设计上比较规整，简单；<br />
											2. 通信或者传递信息的并发性好；<br />
											3. 平衡了计算和IO，因为一般都是计算等待IO。</p>
										</dd>
										<dt>设计劣势点</dt>
										<dd>
											<p>脉冲阵列用在专用的加速芯片上的优势是：<br />
											1. 全局同步受限于时延；<br />
											2. 片上RAM的带宽要求比较大；<br />
											3. 因为缺少互联的协议子系统，而缺少软件上的容错。</p>
										</dd>									
										<dt>分类</dt>
										<dd>
											<p>一维：适合单一的IO，因此用处不是很大；<br />
											二维：一般都是平面矩阵，放了很多的处理单元，但是只允许边界的单元进行IO；<br />
											三维：允许IO经过每个处理单元。</p>
										</dd>
										<dt>举例：使用二维脉动阵列计算矩阵乘</dt>
										<dd>
											<p>使用三个计算单元计算这个矩阵乘的设计<br /><img src="../blogimages/samm1.png" alt="" /><br />
												下面是三个脉动阵列：<br /><img src="../blogimages/samm2.jpg" alt="" /><br />
												下面是每个步骤的过程数据：<br /><img src="../blogimages/samm3.png" alt="" /></p>
										</dd>
										<dt>新增节点</dt>
										<dd>
											<p>从根节点出发，若待插入节点在当前节点切分维度的坐标值小于当前节点在该维度的坐标值时，在其左子树插入；
											若大于等于当前节点在该维度的坐标值时，在其右子树插入。递归遍历，直至叶子节点。如下为新增节点代码：</p>
											<pre><code>def insert(n, point, depth):
    if n is None:
        return Node(point)
    cutting_dim = depth % len(point)
    if point[cutting_dim] < n.location[cutting_dim]:
        if n.left is None:
            n.left = Node(point)
        else:
            insert(n.left, point, depth + 1)
    else:
        if n.right is None:
            n.right = Node(point)
        else:
            insert(n.right, point, depth + 1)
											</code></pre>
										</dd>
										<dt>删除节点</dt>
										<dd>
											<p>假设待删节点T的切分维度为x，下面根据待删节点的几类不同情形进行考虑。<br />
												a）无子树：本身为叶子节点，直接删除。<br />
												b）有右子树：在T.right寻找x切分维度最小的节点p，然后替换被删节点T；递归处理删除节点p。<br />
												c）无右子树有左子树：在T.left寻找x切分维度最小的节点p，即p=findmin(T.left, cutting-dim=x)，
												然后用节点p替换被删节点T；将原T.left作为p.right；递归处理删除节点p。
												（之所以未采用findmax(T.left, cutting-dim=x)节点来替换被删节点，是由于原被删节点的左子树节点存在x维度最大值相等的情形，
												这样就破坏了左子树在x分割维度的坐标需小于其根节点的定义），如下为删除节点代码:</p>
											<pre><code>def delete(n, point, depth):
    cutting_dim = depth % len(point)
    if n.location == point:
        if n.right is not None:
            n.location = findmin(n.right, depth + 1, cutting_dim, None)
            delete(n.right, n.location, depth + 1)
        elif n.left is not None:
            n.location = findmin(n.left, depth + 1)
            delete(n.left, n.location, depth + 1)
            n.right = n.left
            n.left = None
        else:
            n = None
    else:
        if point[cutting_dim] < n.location[cutting_dim]:
            delete(n.left, point, depth + 1)
        else:
            delete(n.right, point, depth + 1)
											</code></pre>
										</dd>
											
										<dt>scikit-learn使用</dt>
										<dd>
											<p>scikit-learn是一个实用的机器学习类库，其有KDTree的实现。如下例子为直观展示，仅构建了一个二维空间的k-d tree，
												然后对其作k近邻搜索及指定半径的范围搜索。多维空间的检索，调用方式与此例相差无多。如下为最近邻搜索代码：</p>
											<pre><code>import numpy as np
from matplotlib import pyplot as plt
from matplotlib.patches import Circle
from sklearn.neighbors import KDTree
np.random.seed(0)
points = np.random.random((100, 2))
tree = KDTree(points)
point = points[0]
# kNN
dists, indices = tree.query([point], k=3)
print(dists, indices)
# query radius
indices = tree.query_radius([point], r=0.2)
print(indices)
fig = plt.figure()
ax = fig.add_subplot(111, aspect='equal')
ax.add_patch(Circle(point, 0.2, color='r', fill=False))
X, Y = [p[0] for p in points], [p[1] for p in points]
plt.scatter(X, Y)
plt.scatter([point[0]], [point[1]], c='r')
plt.show()
											</code></pre>
										</dd>
									</dl>

								<!-- Preformatted Code -->
									<h3>xx</h3>
									<pre><code>import numpy as np

									</code></pre>
								
								<p>引用自：https://www.cnblogs.com/flyinggod/p/8727584.html</p>
							</section>
						
						<!-- Footer -->
							<footer>
								<div class="pagination">
									<ul class="actions special">
										<li><a href="../Blog.html" class="button">Back</a></li>
									</ul>
								</div>
							</footer>

					</div>

				<!-- Footer -->
					<footer id="footer">
						<section class="split contact">
							<section class="alt">
								<h3>Address</h3>
								<p>The Hong Kong Univ. of Sci. and Tech.<br />
								Clear Water Bay, Kowloon, Hong Kong, China </p>
							</section>
							<section>
								<h3>Phone</h3>
								<p>Privacy</p>
							</section>
						</section>
						<section class="split contact">
							<section class="alt">
								<h3>Email</h3>
								<p><a href="MAILTO:hanweifan2018@outlook.com">hanweifan2018@outlook.com</a><br />
									You can write to me either in English or Chinese</p>
							</section>
							<section>
								<h3>Social</h3>
								<ul class="icons alt">
									<li><a href="https://www.linkedin.com/in/hanwei-fan-bb3b69192/" class="icon brands fa-linkedin"><span class="label">Linkdin</span></a></li>
									<li><a href="https://www.instagram.com/fan.hanwei/" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>
									<li><a href="https://github.com/fanhanwei" class="icon brands fa-github"><span class="label">GitHub</span></a></li>
								</ul>
							</section>
						</section>
					</footer>

				<!-- Copyright -->
					<div id="copyright">
						<ul><li>&copy; FAN, Hanwei. All Rights Reserved.</li><li>Design: <a href="https://html5up.net">HTML5 UP</a></li></ul>
					</div>

			</div>

		<!-- Scripts -->
			<script src="../assets/js/jquery.min.js"></script>
			<script src="../assets/js/jquery.scrollex.min.js"></script>
			<script src="../assets/js/jquery.scrolly.min.js"></script>
			<script src="../assets/js/browser.min.js"></script>
			<script src="../assets/js/breakpoints.min.js"></script>
			<script src="../assets/js/util.js"></script>
			<script src="../assets/js/main.js"></script>

	</body>
</html>
